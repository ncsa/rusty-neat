extern crate log;

use std::collections::{HashMap, VecDeque};
use std::io;
use std::io::Write;
use simple_rng::NeatRng;
use common::file_tools::open_file;
use common::structs::nucleotides::sequence_array_to_string;
use common::structs::variants::Variant;

fn genotype_to_string(genotype: &mut Vec<u8>, rng: &mut NeatRng) -> String {
    // Converts a vector of 0s and 1s representing genotype to a standard
    // vcf genotype string.
    //
    // In order to make the vcf look a little more realistic, we shuffle the genotypes, that way
    // it doesn't look like one ploid got all the mutations. I actually don't know if this is
    // realistic or not, but that's what we're doing.
    rng.shuffle_in_place(genotype);
    let geno_str = genotype.iter().map(|x| x.to_string() + "/").collect::<String>();
    geno_str.strip_suffix("/").expect(
        &format!("Problem with genotype string: {:?}", genotype)
    ).to_string()
}

pub fn write_vcf(
    variant_locations: &mut Box<HashMap<String, HashMap<usize, Variant>>>,
    fasta_order: &VecDeque<String>,
    fasta_lengths: &HashMap<String, usize>,
    reference_path: &str,
    overwrite_output: bool,
    output_file_prefix: &str,
    mut rng: &mut NeatRng,
) -> io::Result<()> {
    // Takes:
    // variant_locations: A map of contig names keyed to lists of variants in that contig
    // consisting of a tuple of (position, alt base, ref base).
    // fasta_order: A vector of contig names in the order of the reference fasta.
    // ploidy: The number of copies of each chromosome present in the organism
    // reference_path: The location of the reference file this vcf is showing variants from.
    // output_file_prefix: The path to the directory and the prefix to use for filenames
    // rng: A random number generator for this run
    // Result:
    // Throws and error if there's a problem, or else returns nothing.
    //
    // set the filename of the output vcf
    let mut filename = format!("{}.vcf", output_file_prefix);
    let mut outfile = open_file(&mut filename, overwrite_output)
        .expect(&format!("Problem opening {} for output.", filename));
    // add the vcf header
    writeln!(&mut outfile, "##fileformat=VCFv4.1")?;
    writeln!(&mut outfile, "##reference={}", reference_path)?;
    for contig in fasta_order.iter() {
        let length = fasta_lengths[contig];
        writeln!(
            &mut outfile,
            "##contig=<ID={},length={}>",
            &contig,
            length
        )?;
    }
    writeln!(&mut outfile, "##Generated by rusty-neat")?;
    writeln!(
        &mut outfile,
        "##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Total Depth\">"
    )?;
    writeln!(
        &mut outfile,
        "##INFO=<ID=AF,Number=A,Type=Float,Description=\"Allele Frequency\">"
    )?;
    writeln!(&mut outfile, "##INFO=<ID=VMX,Number=1,Type=String, Description=\"SNP is Missense in these Read Frames\">")?;
    writeln!(&mut outfile, "##INFO=<ID=VNX,Number=1,Type=String, Description=\"SNP is Nonsense in these Read Frames\">")?;
    writeln!(
        &mut outfile,
        "##INFO=<ID=VFX,Number=1,Type=String,Description=\"Indel Causes Frameshift\">"
    )?;
    writeln!(&mut outfile, "##ALT=<ID=DEL,Description=\"Deletion\">")?;
    writeln!(&mut outfile, "##ALT=<ID=DUP,Description=\"Duplication\">")?;
    writeln!(
        &mut outfile,
        "##ALT=<ID=INS,Description=\"Insertion of novel sequence\">"
    )?;
    writeln!(&mut outfile, "##ALT=<ID=INV,Description=\"Inversion\">")?;
    writeln!(
        &mut outfile,
        "##ALT=<ID=CNV,Description=\"Copy number variable region\">"
    )?;
    writeln!(
        &mut outfile,
        "##ALT=<ID=TRANS,Description=\"Translocation\">"
    )?;
    writeln!(
        &mut outfile,
        "##ALT=<ID=INV-TRANS,Description=\"Inverted translocation\">"
    )?;
    writeln!(
        &mut outfile,
        "##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">"
    )?;
    // Add a neat sample column
    writeln!(
        &mut outfile,
        "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tNEAT_simulated_sample"
    )?;
    // insert mutations
    for contig in fasta_order.iter() {
        for (position, mutation) in variant_locations.get_mut(contig).unwrap() {
            // Format the output line. Any fields without data will be a simple period. Quality
            // is set to 37 for all these variants, to indicate in the golden vcf that these are
            // the generated variants.
            let line = format!(
                "{}\t{}\t.\t{}\t{}\t37\tPASS\t.\tGT\t{}",
                contig,
                position + 1,
                sequence_array_to_string(&mutation.reference, &mut rng),
                sequence_array_to_string(&mutation.alternate, &mut rng),
                genotype_to_string(&mut mutation.genotype, &mut rng),
            );
            writeln!(&mut outfile, "{}", line)?;
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::path::Path;
    use simple_rng::NeatRng;
    use common::structs::variants::{Variant, VariantType};

    #[test]
    fn test_genotype_to_string() {
        let mut genotype = vec![0, 1, 0];
        let mut rng = NeatRng::new_from_seed(vec![
            "Hello".to_string(),
            "Cruel".to_string(),
            "World".to_string(),
        ]);
        assert_eq!(String::from("0/1/0"), genotype_to_string(&mut genotype, rng));
    }

    #[test]
    pub fn test_write_vcf() {
        let mut variant_locations = Box::from(HashMap::from([
            (
                "chr1".to_string(),
                HashMap::from([
                    (3, Variant::new(
                        VariantType::SNP,
                        &vec![Ada],
                        &vec![Cyt],
                        vec![1, 0]
                    )
                    ),
                    (7, Variant::new(
                        VariantType::SNP,
                        &vec![Thy],
                        &vec![Gua],
                        vec![1, 1])
                    )
                ])
            )
        ]));
        let fasta_order = VecDeque::from(["chr1".to_string()]);
        let fasta_length = HashMap::from([("chr1".to_string(), 20)]);
        let reference_path = "test_data/references/H1N1.fa";
        let overwrite_output = false;
        let output_file_prefix = "good_test";
        let rng = ChaCha20Rng::seed_from_u64(0);
        let result = write_vcf(
            &mut variant_locations,
            &fasta_order,
            &fasta_length,
            reference_path,
            overwrite_output,
            output_file_prefix,
            rng,
        );
        result.unwrap();
        assert!(Path::new("good_test.vcf").exists());
        fs::remove_file("good_test.vcf").unwrap();
    }
}
